import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/dct/src/dct.js
var require_dct = __commonJS({
  "node_modules/dct/src/dct.js"(exports, module) {
    var cosMap = null;
    var memoizeCosines = function(N) {
      cosMap = cosMap || {};
      cosMap[N] = new Array(N * N);
      var PI_N = Math.PI / N;
      for (var k = 0; k < N; k++) {
        for (var n = 0; n < N; n++) {
          cosMap[N][n + k * N] = Math.cos(PI_N * (n + 0.5) * k);
        }
      }
    };
    function dct(signal, scale) {
      var L = signal.length;
      scale = scale || 2;
      if (!cosMap || !cosMap[L])
        memoizeCosines(L);
      var coefficients = signal.map(function() {
        return 0;
      });
      return coefficients.map(function(__, ix) {
        return scale * signal.reduce(function(prev, cur, ix_, arr) {
          return prev + cur * cosMap[L][ix_ + ix * L];
        }, 0);
      });
    }
    module.exports = dct;
  }
});

// node_modules/dct/index.js
var require_dct2 = __commonJS({
  "node_modules/dct/index.js"(exports, module) {
    module.exports = require_dct();
  }
});

// node_modules/fftjs/dist/utils.js
var require_utils = __commonJS({
  "node_modules/fftjs/dist/utils.js"(exports, module) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var memoizedReversal = {};
    var memoizedZeroBuffers = {};
    var constructComplexArray = function constructComplexArray2(signal) {
      var complexSignal = {};
      complexSignal.real = signal.real === void 0 ? signal.slice() : signal.real.slice();
      var bufferSize = complexSignal.real.length;
      if (memoizedZeroBuffers[bufferSize] === void 0) {
        memoizedZeroBuffers[bufferSize] = Array.apply(null, Array(bufferSize)).map(Number.prototype.valueOf, 0);
      }
      complexSignal.imag = memoizedZeroBuffers[bufferSize].slice();
      return complexSignal;
    };
    var bitReverseArray = function bitReverseArray2(N) {
      if (memoizedReversal[N] === void 0) {
        var maxBinaryLength = (N - 1).toString(2).length;
        var templateBinary = "0".repeat(maxBinaryLength);
        var reversed = {};
        for (var n = 0; n < N; n++) {
          var currBinary = n.toString(2);
          currBinary = templateBinary.substr(currBinary.length) + currBinary;
          currBinary = [].concat(_toConsumableArray(currBinary)).reverse().join("");
          reversed[n] = parseInt(currBinary, 2);
        }
        memoizedReversal[N] = reversed;
      }
      return memoizedReversal[N];
    };
    var multiply = function multiply2(a, b) {
      return {
        "real": a.real * b.real - a.imag * b.imag,
        "imag": a.real * b.imag + a.imag * b.real
      };
    };
    var add = function add2(a, b) {
      return {
        "real": a.real + b.real,
        "imag": a.imag + b.imag
      };
    };
    var subtract = function subtract2(a, b) {
      return {
        "real": a.real - b.real,
        "imag": a.imag - b.imag
      };
    };
    var euler = function euler2(kn, N) {
      var x2 = -2 * Math.PI * kn / N;
      return { "real": Math.cos(x2), "imag": Math.sin(x2) };
    };
    var conj = function conj2(a) {
      a.imag *= -1;
      return a;
    };
    module.exports = {
      bitReverseArray,
      multiply,
      add,
      subtract,
      euler,
      conj,
      constructComplexArray
    };
  }
});

// node_modules/fftjs/dist/fft.js
var require_fft = __commonJS({
  "node_modules/fftjs/dist/fft.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var fft = function fft2(signal) {
      var complexSignal = {};
      if (signal.real === void 0 || signal.imag === void 0) {
        complexSignal = utils.constructComplexArray(signal);
      } else {
        complexSignal.real = signal.real.slice();
        complexSignal.imag = signal.imag.slice();
      }
      var N = complexSignal.real.length;
      var logN = Math.log2(N);
      if (Math.round(logN) != logN)
        throw new Error("Input size must be a power of 2.");
      if (complexSignal.real.length != complexSignal.imag.length) {
        throw new Error("Real and imaginary components must have the same length.");
      }
      var bitReversedIndices = utils.bitReverseArray(N);
      var ordered = {
        "real": [],
        "imag": []
      };
      for (var i = 0; i < N; i++) {
        ordered.real[bitReversedIndices[i]] = complexSignal.real[i];
        ordered.imag[bitReversedIndices[i]] = complexSignal.imag[i];
      }
      for (var _i = 0; _i < N; _i++) {
        complexSignal.real[_i] = ordered.real[_i];
        complexSignal.imag[_i] = ordered.imag[_i];
      }
      for (var n = 1; n <= logN; n++) {
        var currN = Math.pow(2, n);
        for (var k = 0; k < currN / 2; k++) {
          var twiddle = utils.euler(k, currN);
          for (var m = 0; m < N / currN; m++) {
            var currEvenIndex = currN * m + k;
            var currOddIndex = currN * m + k + currN / 2;
            var currEvenIndexSample = {
              "real": complexSignal.real[currEvenIndex],
              "imag": complexSignal.imag[currEvenIndex]
            };
            var currOddIndexSample = {
              "real": complexSignal.real[currOddIndex],
              "imag": complexSignal.imag[currOddIndex]
            };
            var odd = utils.multiply(twiddle, currOddIndexSample);
            var subtractionResult = utils.subtract(currEvenIndexSample, odd);
            complexSignal.real[currOddIndex] = subtractionResult.real;
            complexSignal.imag[currOddIndex] = subtractionResult.imag;
            var additionResult = utils.add(odd, currEvenIndexSample);
            complexSignal.real[currEvenIndex] = additionResult.real;
            complexSignal.imag[currEvenIndex] = additionResult.imag;
          }
        }
      }
      return complexSignal;
    };
    var ifft = function ifft2(signal) {
      if (signal.real === void 0 || signal.imag === void 0) {
        throw new Error("IFFT only accepts a complex input.");
      }
      var N = signal.real.length;
      var complexSignal = {
        "real": [],
        "imag": []
      };
      for (var i = 0; i < N; i++) {
        var currentSample = {
          "real": signal.real[i],
          "imag": signal.imag[i]
        };
        var conjugateSample = utils.conj(currentSample);
        complexSignal.real[i] = conjugateSample.real;
        complexSignal.imag[i] = conjugateSample.imag;
      }
      var X = fft(complexSignal);
      complexSignal.real = X.real.map(function(val) {
        return val / N;
      });
      complexSignal.imag = X.imag.map(function(val) {
        return val / N;
      });
      return complexSignal;
    };
    module.exports = {
      fft,
      ifft
    };
  }
});

// node_modules/meyda/dist/web/meyda.min.js
var require_meyda_min = __commonJS({
  "node_modules/meyda/dist/web/meyda.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require_dct2(), require_fft()) : "function" == typeof define && define.amd ? define(["dct", "fftjs"], e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Meyda = e(t.dct, t.fftjs);
    }(exports, function(t, e) {
      "use strict";
      function r(t2, e2, r2) {
        if (r2 || 2 === arguments.length)
          for (var n2, a2 = 0, o2 = e2.length; a2 < o2; a2++)
            !n2 && a2 in e2 || (n2 || (n2 = Array.prototype.slice.call(e2, 0, a2)), n2[a2] = e2[a2]);
        return t2.concat(n2 || Array.prototype.slice.call(e2));
      }
      var n = Object.freeze({ __proto__: null, blackman: function(t2) {
        for (var e2 = new Float32Array(t2), r2 = 2 * Math.PI / (t2 - 1), n2 = 2 * r2, a2 = 0; a2 < t2 / 2; a2++)
          e2[a2] = 0.42 - 0.5 * Math.cos(a2 * r2) + 0.08 * Math.cos(a2 * n2);
        for (a2 = Math.ceil(t2 / 2); a2 > 0; a2--)
          e2[t2 - a2] = e2[a2 - 1];
        return e2;
      }, hamming: function(t2) {
        for (var e2 = new Float32Array(t2), r2 = 0; r2 < t2; r2++)
          e2[r2] = 0.54 - 0.46 * Math.cos(2 * Math.PI * (r2 / t2 - 1));
        return e2;
      }, hanning: function(t2) {
        for (var e2 = new Float32Array(t2), r2 = 0; r2 < t2; r2++)
          e2[r2] = 0.5 - 0.5 * Math.cos(2 * Math.PI * r2 / (t2 - 1));
        return e2;
      }, sine: function(t2) {
        for (var e2 = Math.PI / (t2 - 1), r2 = new Float32Array(t2), n2 = 0; n2 < t2; n2++)
          r2[n2] = Math.sin(e2 * n2);
        return r2;
      } }), a = {};
      function o(t2) {
        for (; t2 % 2 == 0 && t2 > 1; )
          t2 /= 2;
        return 1 === t2;
      }
      function i(t2, e2) {
        if ("rect" !== e2) {
          if ("" !== e2 && e2 || (e2 = "hanning"), a[e2] || (a[e2] = {}), !a[e2][t2.length])
            try {
              a[e2][t2.length] = n[e2](t2.length);
            } catch (t3) {
              throw new Error("Invalid windowing function");
            }
          t2 = function(t3, e3) {
            for (var r2 = [], n2 = 0; n2 < Math.min(t3.length, e3.length); n2++)
              r2[n2] = t3[n2] * e3[n2];
            return r2;
          }(t2, a[e2][t2.length]);
        }
        return t2;
      }
      function u(t2, e2, r2) {
        for (var n2 = new Float32Array(t2), a2 = 0; a2 < n2.length; a2++)
          n2[a2] = a2 * e2 / r2, n2[a2] = 13 * Math.atan(n2[a2] / 1315.8) + 3.5 * Math.atan(Math.pow(n2[a2] / 7518, 2));
        return n2;
      }
      function f(t2) {
        return Float32Array.from(t2);
      }
      function s(t2) {
        return 1125 * Math.log(1 + t2 / 700);
      }
      function c(t2, e2, r2) {
        for (var n2, a2 = new Float32Array(t2 + 2), o2 = new Float32Array(t2 + 2), i2 = e2 / 2, u2 = s(0), f2 = (s(i2) - u2) / (t2 + 1), c2 = new Array(t2 + 2), p2 = 0; p2 < a2.length; p2++)
          a2[p2] = p2 * f2, o2[p2] = (n2 = a2[p2], 700 * (Math.exp(n2 / 1125) - 1)), c2[p2] = Math.floor((r2 + 1) * o2[p2] / e2);
        for (var h2 = new Array(t2), m2 = 0; m2 < h2.length; m2++) {
          h2[m2] = new Array(r2 / 2 + 1).fill(0);
          for (p2 = c2[m2]; p2 < c2[m2 + 1]; p2++)
            h2[m2][p2] = (p2 - c2[m2]) / (c2[m2 + 1] - c2[m2]);
          for (p2 = c2[m2 + 1]; p2 < c2[m2 + 2]; p2++)
            h2[m2][p2] = (c2[m2 + 2] - p2) / (c2[m2 + 2] - c2[m2 + 1]);
        }
        return h2;
      }
      function p(t2, e2, n2, a2, o2, i2, u2) {
        void 0 === a2 && (a2 = 5), void 0 === o2 && (o2 = 2), void 0 === i2 && (i2 = true), void 0 === u2 && (u2 = 440);
        var f2 = Math.floor(n2 / 2) + 1, s2 = new Array(n2).fill(0).map(function(r2, a3) {
          return t2 * function(t3, e3) {
            return Math.log2(16 * t3 / e3);
          }(e2 * a3 / n2, u2);
        });
        s2[0] = s2[1] - 1.5 * t2;
        var c2, p2, h2, m2 = s2.slice(1).map(function(t3, e3) {
          return Math.max(t3 - s2[e3]);
        }, 1).concat([1]), l2 = Math.round(t2 / 2), w2 = new Array(t2).fill(0).map(function(e3, r2) {
          return s2.map(function(e4) {
            return (10 * t2 + l2 + e4 - r2) % t2 - l2;
          });
        }), d2 = w2.map(function(t3, e3) {
          return t3.map(function(t4, r2) {
            return Math.exp(-0.5 * Math.pow(2 * w2[e3][r2] / m2[r2], 2));
          });
        });
        if (p2 = (c2 = d2)[0].map(function() {
          return 0;
        }), h2 = c2.reduce(function(t3, e3) {
          return e3.forEach(function(e4, r2) {
            t3[r2] += Math.pow(e4, 2);
          }), t3;
        }, p2).map(Math.sqrt), d2 = c2.map(function(t3, e3) {
          return t3.map(function(t4, e4) {
            return t4 / (h2[e4] || 1);
          });
        }), o2) {
          var S2 = s2.map(function(e3) {
            return Math.exp(-0.5 * Math.pow((e3 / t2 - a2) / o2, 2));
          });
          d2 = d2.map(function(t3) {
            return t3.map(function(t4, e3) {
              return t4 * S2[e3];
            });
          });
        }
        return i2 && (d2 = r(r([], d2.slice(3), true), d2.slice(0, 3), true)), d2.map(function(t3) {
          return t3.slice(0, f2);
        });
      }
      function h(t2, e2) {
        for (var r2 = 0, n2 = 0, a2 = 0; a2 < e2.length; a2++)
          r2 += Math.pow(a2, t2) * Math.abs(e2[a2]), n2 += e2[a2];
        return r2 / n2;
      }
      function m(t2) {
        var e2 = t2.ampSpectrum, r2 = t2.barkScale, n2 = t2.numberOfBarkBands, a2 = void 0 === n2 ? 24 : n2;
        if ("object" != typeof e2 || "object" != typeof r2)
          throw new TypeError();
        var o2 = a2, i2 = new Float32Array(o2), u2 = 0, f2 = e2, s2 = new Int32Array(o2 + 1);
        s2[0] = 0;
        for (var c2 = r2[f2.length - 1] / o2, p2 = 1, h2 = 0; h2 < f2.length; h2++)
          for (; r2[h2] > c2; )
            s2[p2++] = h2, c2 = p2 * r2[f2.length - 1] / o2;
        s2[o2] = f2.length - 1;
        for (h2 = 0; h2 < o2; h2++) {
          for (var m2 = 0, l2 = s2[h2]; l2 < s2[h2 + 1]; l2++)
            m2 += f2[l2];
          i2[h2] = Math.pow(m2, 0.23);
        }
        for (h2 = 0; h2 < i2.length; h2++)
          u2 += i2[h2];
        return { specific: i2, total: u2 };
      }
      function l(t2) {
        var e2 = t2.ampSpectrum;
        if ("object" != typeof e2)
          throw new TypeError();
        for (var r2 = new Float32Array(e2.length), n2 = 0; n2 < r2.length; n2++)
          r2[n2] = Math.pow(e2[n2], 2);
        return r2;
      }
      function w(t2) {
        var e2 = t2.ampSpectrum, r2 = t2.melFilterBank, n2 = t2.bufferSize;
        if ("object" != typeof e2)
          throw new TypeError("Valid ampSpectrum is required to generate melBands");
        if ("object" != typeof r2)
          throw new TypeError("Valid melFilterBank is required to generate melBands");
        for (var a2 = l({ ampSpectrum: e2 }), o2 = r2.length, i2 = Array(o2), u2 = new Float32Array(o2), f2 = 0; f2 < u2.length; f2++) {
          i2[f2] = new Float32Array(n2 / 2), u2[f2] = 0;
          for (var s2 = 0; s2 < n2 / 2; s2++)
            i2[f2][s2] = r2[f2][s2] * a2[s2], u2[f2] += i2[f2][s2];
          u2[f2] = Math.log(u2[f2] + 1);
        }
        return Array.prototype.slice.call(u2);
      }
      var d = Object.freeze({ __proto__: null, amplitudeSpectrum: function(t2) {
        return t2.ampSpectrum;
      }, buffer: function(t2) {
        return t2.signal;
      }, chroma: function(t2) {
        var e2 = t2.ampSpectrum, r2 = t2.chromaFilterBank;
        if ("object" != typeof e2)
          throw new TypeError("Valid ampSpectrum is required to generate chroma");
        if ("object" != typeof r2)
          throw new TypeError("Valid chromaFilterBank is required to generate chroma");
        var n2 = r2.map(function(t3, r3) {
          return e2.reduce(function(e3, r4, n3) {
            return e3 + r4 * t3[n3];
          }, 0);
        }), a2 = Math.max.apply(Math, n2);
        return a2 ? n2.map(function(t3) {
          return t3 / a2;
        }) : n2;
      }, complexSpectrum: function(t2) {
        return t2.complexSpectrum;
      }, energy: function(t2) {
        var e2 = t2.signal;
        if ("object" != typeof e2)
          throw new TypeError();
        for (var r2 = 0, n2 = 0; n2 < e2.length; n2++)
          r2 += Math.pow(Math.abs(e2[n2]), 2);
        return r2;
      }, loudness: m, melBands: w, mfcc: function(e2) {
        var r2 = e2.ampSpectrum, n2 = e2.melFilterBank, a2 = e2.numberOfMFCCCoefficients, o2 = e2.bufferSize, i2 = Math.min(40, Math.max(1, a2 || 13));
        if (n2.length < i2)
          throw new Error("Insufficient filter bank for requested number of coefficients");
        var u2 = w({ ampSpectrum: r2, melFilterBank: n2, bufferSize: o2 });
        return t(u2).slice(0, i2);
      }, perceptualSharpness: function(t2) {
        for (var e2 = m({ ampSpectrum: t2.ampSpectrum, barkScale: t2.barkScale }), r2 = e2.specific, n2 = 0, a2 = 0; a2 < r2.length; a2++)
          n2 += a2 < 15 ? (a2 + 1) * r2[a2 + 1] : 0.066 * Math.exp(0.171 * (a2 + 1));
        return n2 *= 0.11 / e2.total;
      }, perceptualSpread: function(t2) {
        for (var e2 = m({ ampSpectrum: t2.ampSpectrum, barkScale: t2.barkScale }), r2 = 0, n2 = 0; n2 < e2.specific.length; n2++)
          e2.specific[n2] > r2 && (r2 = e2.specific[n2]);
        return Math.pow((e2.total - r2) / e2.total, 2);
      }, powerSpectrum: l, rms: function(t2) {
        var e2 = t2.signal;
        if ("object" != typeof e2)
          throw new TypeError();
        for (var r2 = 0, n2 = 0; n2 < e2.length; n2++)
          r2 += Math.pow(e2[n2], 2);
        return r2 /= e2.length, r2 = Math.sqrt(r2);
      }, spectralCentroid: function(t2) {
        var e2 = t2.ampSpectrum;
        if ("object" != typeof e2)
          throw new TypeError();
        return h(1, e2);
      }, spectralCrest: function(t2) {
        var e2 = t2.ampSpectrum;
        if ("object" != typeof e2)
          throw new TypeError();
        var r2 = 0, n2 = -1 / 0;
        return e2.forEach(function(t3) {
          r2 += Math.pow(t3, 2), n2 = t3 > n2 ? t3 : n2;
        }), r2 /= e2.length, r2 = Math.sqrt(r2), n2 / r2;
      }, spectralFlatness: function(t2) {
        var e2 = t2.ampSpectrum;
        if ("object" != typeof e2)
          throw new TypeError();
        for (var r2 = 0, n2 = 0, a2 = 0; a2 < e2.length; a2++)
          r2 += Math.log(e2[a2]), n2 += e2[a2];
        return Math.exp(r2 / e2.length) * e2.length / n2;
      }, spectralFlux: function(t2) {
        var e2 = t2.signal, r2 = t2.previousSignal, n2 = t2.bufferSize;
        if ("object" != typeof e2 || "object" != typeof r2)
          throw new TypeError();
        for (var a2 = 0, o2 = -n2 / 2; o2 < e2.length / 2 - 1; o2++)
          x = Math.abs(e2[o2]) - Math.abs(r2[o2]), a2 += (x + Math.abs(x)) / 2;
        return a2;
      }, spectralKurtosis: function(t2) {
        var e2 = t2.ampSpectrum;
        if ("object" != typeof e2)
          throw new TypeError();
        var r2 = e2, n2 = h(1, r2), a2 = h(2, r2), o2 = h(3, r2), i2 = h(4, r2);
        return (-3 * Math.pow(n2, 4) + 6 * n2 * a2 - 4 * n2 * o2 + i2) / Math.pow(Math.sqrt(a2 - Math.pow(n2, 2)), 4);
      }, spectralRolloff: function(t2) {
        var e2 = t2.ampSpectrum, r2 = t2.sampleRate;
        if ("object" != typeof e2)
          throw new TypeError();
        for (var n2 = e2, a2 = r2 / (2 * (n2.length - 1)), o2 = 0, i2 = 0; i2 < n2.length; i2++)
          o2 += n2[i2];
        for (var u2 = 0.99 * o2, f2 = n2.length - 1; o2 > u2 && f2 >= 0; )
          o2 -= n2[f2], --f2;
        return (f2 + 1) * a2;
      }, spectralSkewness: function(t2) {
        var e2 = t2.ampSpectrum;
        if ("object" != typeof e2)
          throw new TypeError();
        var r2 = h(1, e2), n2 = h(2, e2), a2 = h(3, e2);
        return (2 * Math.pow(r2, 3) - 3 * r2 * n2 + a2) / Math.pow(Math.sqrt(n2 - Math.pow(r2, 2)), 3);
      }, spectralSlope: function(t2) {
        var e2 = t2.ampSpectrum, r2 = t2.sampleRate, n2 = t2.bufferSize;
        if ("object" != typeof e2)
          throw new TypeError();
        for (var a2 = 0, o2 = 0, i2 = new Float32Array(e2.length), u2 = 0, f2 = 0, s2 = 0; s2 < e2.length; s2++) {
          a2 += e2[s2];
          var c2 = s2 * r2 / n2;
          i2[s2] = c2, u2 += c2 * c2, o2 += c2, f2 += c2 * e2[s2];
        }
        return (e2.length * f2 - o2 * a2) / (a2 * (u2 - Math.pow(o2, 2)));
      }, spectralSpread: function(t2) {
        var e2 = t2.ampSpectrum;
        if ("object" != typeof e2)
          throw new TypeError();
        return Math.sqrt(h(2, e2) - Math.pow(h(1, e2), 2));
      }, zcr: function(t2) {
        var e2 = t2.signal;
        if ("object" != typeof e2)
          throw new TypeError();
        for (var r2 = 0, n2 = 1; n2 < e2.length; n2++)
          (e2[n2 - 1] >= 0 && e2[n2] < 0 || e2[n2 - 1] < 0 && e2[n2] >= 0) && r2++;
        return r2;
      } }), S = function() {
        function t2(t3, e2) {
          var r2 = this;
          if (this._m = e2, !t3.audioContext)
            throw this._m.errors.noAC;
          if (t3.bufferSize && !o(t3.bufferSize))
            throw this._m._errors.notPow2;
          if (!t3.source)
            throw this._m._errors.noSource;
          this._m.audioContext = t3.audioContext, this._m.bufferSize = t3.bufferSize || this._m.bufferSize || 256, this._m.hopSize = t3.hopSize || this._m.hopSize || this._m.bufferSize, this._m.sampleRate = t3.sampleRate || this._m.audioContext.sampleRate || 44100, this._m.callback = t3.callback, this._m.windowingFunction = t3.windowingFunction || "hanning", this._m.featureExtractors = d, this._m.EXTRACTION_STARTED = t3.startImmediately || false, this._m.channel = "number" == typeof t3.channel ? t3.channel : 0, this._m.inputs = t3.inputs || 1, this._m.outputs = t3.outputs || 1, this._m.numberOfMFCCCoefficients = t3.numberOfMFCCCoefficients || this._m.numberOfMFCCCoefficients || 13, this._m.numberOfBarkBands = t3.numberOfBarkBands || this._m.numberOfBarkBands || 24, this._m.spn = this._m.audioContext.createScriptProcessor(this._m.bufferSize, this._m.inputs, this._m.outputs), this._m.spn.connect(this._m.audioContext.destination), this._m._featuresToExtract = t3.featureExtractors || [], this._m.barkScale = u(this._m.bufferSize, this._m.sampleRate, this._m.bufferSize), this._m.melFilterBank = c(Math.max(this._m.melBands, this._m.numberOfMFCCCoefficients), this._m.sampleRate, this._m.bufferSize), this._m.inputData = null, this._m.previousInputData = null, this._m.frame = null, this._m.previousFrame = null, this.setSource(t3.source), this._m.spn.onaudioprocess = function(t4) {
            var e3;
            null !== r2._m.inputData && (r2._m.previousInputData = r2._m.inputData), r2._m.inputData = t4.inputBuffer.getChannelData(r2._m.channel), r2._m.previousInputData ? ((e3 = new Float32Array(r2._m.previousInputData.length + r2._m.inputData.length - r2._m.hopSize)).set(r2._m.previousInputData.slice(r2._m.hopSize)), e3.set(r2._m.inputData, r2._m.previousInputData.length - r2._m.hopSize)) : e3 = r2._m.inputData;
            var n2 = function(t5, e4, r3) {
              if (t5.length < e4)
                throw new Error("Buffer is too short for frame length");
              if (r3 < 1)
                throw new Error("Hop length cannot be less that 1");
              if (e4 < 1)
                throw new Error("Frame length cannot be less that 1");
              var n3 = 1 + Math.floor((t5.length - e4) / r3);
              return new Array(n3).fill(0).map(function(n4, a2) {
                return t5.slice(a2 * r3, a2 * r3 + e4);
              });
            }(e3, r2._m.bufferSize, r2._m.hopSize);
            n2.forEach(function(t5) {
              r2._m.frame = t5;
              var e4 = r2._m.extract(r2._m._featuresToExtract, r2._m.frame, r2._m.previousFrame);
              "function" == typeof r2._m.callback && r2._m.EXTRACTION_STARTED && r2._m.callback(e4), r2._m.previousFrame = r2._m.frame;
            });
          };
        }
        return t2.prototype.start = function(t3) {
          this._m._featuresToExtract = t3 || this._m._featuresToExtract, this._m.EXTRACTION_STARTED = true;
        }, t2.prototype.stop = function() {
          this._m.EXTRACTION_STARTED = false;
        }, t2.prototype.setSource = function(t3) {
          this._m.source && this._m.source.disconnect(this._m.spn), this._m.source = t3, this._m.source.connect(this._m.spn);
        }, t2.prototype.setChannel = function(t3) {
          t3 <= this._m.inputs ? this._m.channel = t3 : console.error("Channel ".concat(t3, " does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(t3, " when instantiating the MeydaAnalyzer"));
        }, t2.prototype.get = function(t3) {
          return this._m.inputData ? this._m.extract(t3 || this._m._featuresToExtract, this._m.inputData, this._m.previousInputData) : null;
        }, t2;
      }(), _ = { audioContext: null, spn: null, bufferSize: 512, sampleRate: 44100, melBands: 26, chromaBands: 12, callback: null, windowingFunction: "hanning", featureExtractors: d, EXTRACTION_STARTED: false, numberOfMFCCCoefficients: 13, numberOfBarkBands: 24, _featuresToExtract: [], windowing: i, _errors: { notPow2: new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"), featureUndef: new Error("Meyda: No features defined."), invalidFeatureFmt: new Error("Meyda: Invalid feature format"), invalidInput: new Error("Meyda: Invalid input."), noAC: new Error("Meyda: No AudioContext specified."), noSource: new Error("Meyda: No source node specified.") }, createMeydaAnalyzer: function(t2) {
        return new S(t2, Object.assign({}, _));
      }, listAvailableFeatureExtractors: function() {
        return Object.keys(this.featureExtractors);
      }, extract: function(t2, e2, r2) {
        var n2 = this;
        if (!e2)
          throw this._errors.invalidInput;
        if ("object" != typeof e2)
          throw this._errors.invalidInput;
        if (!t2)
          throw this._errors.featureUndef;
        if (!o(e2.length))
          throw this._errors.notPow2;
        void 0 !== this.barkScale && this.barkScale.length == this.bufferSize || (this.barkScale = u(this.bufferSize, this.sampleRate, this.bufferSize)), void 0 !== this.melFilterBank && this.barkScale.length == this.bufferSize && this.melFilterBank.length == this.melBands || (this.melFilterBank = c(Math.max(this.melBands, this.numberOfMFCCCoefficients), this.sampleRate, this.bufferSize)), void 0 !== this.chromaFilterBank && this.chromaFilterBank.length == this.chromaBands || (this.chromaFilterBank = p(this.chromaBands, this.sampleRate, this.bufferSize)), "buffer" in e2 && void 0 === e2.buffer ? this.signal = f(e2) : this.signal = e2;
        var a2 = v(e2, this.windowingFunction, this.bufferSize);
        if (this.signal = a2.windowedSignal, this.complexSpectrum = a2.complexSpectrum, this.ampSpectrum = a2.ampSpectrum, r2) {
          var i2 = v(r2, this.windowingFunction, this.bufferSize);
          this.previousSignal = i2.windowedSignal, this.previousComplexSpectrum = i2.complexSpectrum, this.previousAmpSpectrum = i2.ampSpectrum;
        }
        var s2 = function(t3) {
          return n2.featureExtractors[t3]({ ampSpectrum: n2.ampSpectrum, chromaFilterBank: n2.chromaFilterBank, complexSpectrum: n2.complexSpectrum, signal: n2.signal, bufferSize: n2.bufferSize, sampleRate: n2.sampleRate, barkScale: n2.barkScale, melFilterBank: n2.melFilterBank, previousSignal: n2.previousSignal, previousAmpSpectrum: n2.previousAmpSpectrum, previousComplexSpectrum: n2.previousComplexSpectrum, numberOfMFCCCoefficients: n2.numberOfMFCCCoefficients, numberOfBarkBands: n2.numberOfBarkBands });
        };
        if ("object" == typeof t2)
          return t2.reduce(function(t3, e3) {
            var r3;
            return Object.assign({}, t3, ((r3 = {})[e3] = s2(e3), r3));
          }, {});
        if ("string" == typeof t2)
          return s2(t2);
        throw this._errors.invalidFeatureFmt;
      } }, v = function(t2, r2, n2) {
        var a2 = {};
        void 0 === t2.buffer ? a2.signal = f(t2) : a2.signal = t2, a2.windowedSignal = i(a2.signal, r2), a2.complexSpectrum = e.fft(a2.windowedSignal), a2.ampSpectrum = new Float32Array(n2 / 2);
        for (var o2 = 0; o2 < n2 / 2; o2++)
          a2.ampSpectrum[o2] = Math.sqrt(Math.pow(a2.complexSpectrum.real[o2], 2) + Math.pow(a2.complexSpectrum.imag[o2], 2));
        return a2;
      };
      return "undefined" != typeof window && (window.Meyda = _), _;
    });
  }
});
export default require_meyda_min();
//# sourceMappingURL=meyda.js.map
