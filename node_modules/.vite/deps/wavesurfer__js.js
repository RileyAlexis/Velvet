import "./chunk-76J2PTFD.js";

// node_modules/wavesurfer.js/dist/wavesurfer.esm.js
function t(t2, e2, i2, s2) {
  return new (i2 || (i2 = Promise))(function(n2, r2) {
    function o2(t3) {
      try {
        h2(s2.next(t3));
      } catch (t4) {
        r2(t4);
      }
    }
    function a2(t3) {
      try {
        h2(s2.throw(t3));
      } catch (t4) {
        r2(t4);
      }
    }
    function h2(t3) {
      var e3;
      t3.done ? n2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(o2, a2);
    }
    h2((s2 = s2.apply(t2, e2 || [])).next());
  });
}
var e = { decode: function(e2, i2) {
  return t(this, void 0, void 0, function* () {
    const t2 = new AudioContext({ sampleRate: i2 }), s2 = t2.decodeAudioData(e2);
    return s2.finally(() => t2.close()), s2;
  });
}, createBuffer: function(t2, e2) {
  return "number" == typeof t2[0] && (t2 = [t2]), function(t3) {
    const e3 = t3[0];
    if (e3.some((t4) => t4 > 1 || t4 < -1)) {
      const i2 = e3.length;
      let s2 = 0;
      for (let t4 = 0; t4 < i2; t4++) {
        const i3 = Math.abs(e3[t4]);
        i3 > s2 && (s2 = i3);
      }
      for (const e4 of t3)
        for (let t4 = 0; t4 < i2; t4++)
          e4[t4] /= s2;
    }
  }(t2), { duration: e2, length: t2[0].length, sampleRate: t2[0].length / e2, numberOfChannels: t2.length, getChannelData: (e3) => null == t2 ? void 0 : t2[e3], copyFromChannel: AudioBuffer.prototype.copyFromChannel, copyToChannel: AudioBuffer.prototype.copyToChannel };
} };
var i = { fetchBlob: function(e2, i2) {
  return t(this, void 0, void 0, function* () {
    return fetch(e2, i2).then((t2) => t2.blob());
  });
} };
var s = class {
  constructor() {
    this.listeners = {};
  }
  on(t2, e2) {
    return this.listeners[t2] || (this.listeners[t2] = /* @__PURE__ */ new Set()), this.listeners[t2].add(e2), () => this.un(t2, e2);
  }
  once(t2, e2) {
    const i2 = this.on(t2, e2), s2 = this.on(t2, () => {
      i2(), s2();
    });
    return i2;
  }
  un(t2, e2) {
    this.listeners[t2] && (e2 ? this.listeners[t2].delete(e2) : delete this.listeners[t2]);
  }
  unAll() {
    this.listeners = {};
  }
  emit(t2, ...e2) {
    this.listeners[t2] && this.listeners[t2].forEach((t3) => t3(...e2));
  }
};
var n = class extends s {
  constructor(t2) {
    super(), t2.media ? this.media = t2.media : this.media = document.createElement("audio"), t2.mediaControls && (this.media.controls = true), t2.autoplay && (this.media.autoplay = true), null != t2.playbackRate && (this.media.playbackRate = t2.playbackRate);
  }
  onMediaEvent(t2, e2, i2) {
    return this.media.addEventListener(t2, e2, i2), () => this.media.removeEventListener(t2, e2);
  }
  onceMediaEvent(t2, e2) {
    return this.onMediaEvent(t2, e2, { once: true });
  }
  getSrc() {
    return this.media.currentSrc || this.media.src || "";
  }
  revokeSrc() {
    const t2 = this.getSrc();
    t2.startsWith("blob:") && URL.revokeObjectURL(t2);
  }
  setSrc(t2, e2) {
    if (this.getSrc() === t2)
      return;
    this.revokeSrc();
    const i2 = e2 instanceof Blob ? URL.createObjectURL(e2) : t2;
    this.media.src = i2, this.media.load();
  }
  destroy() {
    this.media.pause(), this.revokeSrc(), this.media.src = "", this.media.load();
  }
  play() {
    return this.media.play();
  }
  pause() {
    this.media.pause();
  }
  isPlaying() {
    return this.media.currentTime > 0 && !this.media.paused && !this.media.ended;
  }
  setTime(t2) {
    this.media.currentTime = t2;
  }
  getDuration() {
    return this.media.duration;
  }
  getCurrentTime() {
    return this.media.currentTime;
  }
  getVolume() {
    return this.media.volume;
  }
  setVolume(t2) {
    this.media.volume = t2;
  }
  getMuted() {
    return this.media.muted;
  }
  setMuted(t2) {
    this.media.muted = t2;
  }
  getPlaybackRate() {
    return this.media.playbackRate;
  }
  setPlaybackRate(t2, e2) {
    null != e2 && (this.media.preservesPitch = e2), this.media.playbackRate = t2;
  }
  getMediaElement() {
    return this.media;
  }
  setSinkId(t2) {
    return this.media.setSinkId(t2);
  }
};
var r = class _r extends s {
  constructor(t2, e2) {
    let i2;
    if (super(), this.timeouts = [], this.isScrolling = false, this.audioData = null, this.resizeObserver = null, this.isDragging = false, this.options = t2, "string" == typeof t2.container ? i2 = document.querySelector(t2.container) : t2.container instanceof HTMLElement && (i2 = t2.container), !i2)
      throw new Error("Container not found");
    this.parent = i2;
    const [s2, n2] = this.initHtml();
    i2.appendChild(s2), this.container = s2, this.scrollContainer = n2.querySelector(".scroll"), this.wrapper = n2.querySelector(".wrapper"), this.canvasWrapper = n2.querySelector(".canvases"), this.progressWrapper = n2.querySelector(".progress"), this.cursor = n2.querySelector(".cursor"), e2 && n2.appendChild(e2), this.initEvents();
  }
  initEvents() {
    this.wrapper.addEventListener("click", (t3) => {
      const e2 = this.wrapper.getBoundingClientRect(), i2 = (t3.clientX - e2.left) / e2.width;
      this.emit("click", i2);
    }), this.initDrag(), this.scrollContainer.addEventListener("scroll", () => {
      const { scrollLeft: t3, scrollWidth: e2, clientWidth: i2 } = this.scrollContainer, s2 = t3 / e2, n2 = (t3 + i2) / e2;
      this.emit("scroll", s2, n2);
    });
    const t2 = this.createDelay(100);
    this.resizeObserver = new ResizeObserver(() => {
      t2(() => this.reRender());
    }), this.resizeObserver.observe(this.scrollContainer);
  }
  initDrag() {
    !function(t2, e2, i2, s2, n2 = 5) {
      let r2 = () => {
      };
      if (!t2)
        return r2;
      const o2 = (o3) => {
        if (2 === o3.button)
          return;
        o3.preventDefault(), o3.stopPropagation();
        let a2 = o3.clientX, h2 = o3.clientY, l = false;
        const d = (s3) => {
          s3.preventDefault(), s3.stopPropagation();
          const r3 = s3.clientX, o4 = s3.clientY;
          if (l || Math.abs(r3 - a2) >= n2 || Math.abs(o4 - h2) >= n2) {
            const { left: s4, top: n3 } = t2.getBoundingClientRect();
            l || (l = true, null == i2 || i2(a2 - s4, h2 - n3)), e2(r3 - a2, o4 - h2, r3 - s4, o4 - n3), a2 = r3, h2 = o4;
          }
        }, c = (t3) => {
          l && (t3.preventDefault(), t3.stopPropagation());
        }, u = () => {
          l && (null == s2 || s2()), r2();
        };
        document.addEventListener("pointermove", d), document.addEventListener("pointerup", u), document.addEventListener("pointerleave", u), document.addEventListener("click", c, true), r2 = () => {
          document.removeEventListener("pointermove", d), document.removeEventListener("pointerup", u), document.removeEventListener("pointerleave", u), setTimeout(() => {
            document.removeEventListener("click", c, true);
          }, 10);
        };
      };
      t2.addEventListener("pointerdown", o2);
    }(this.wrapper, (t2, e2, i2) => {
      this.emit("drag", Math.max(0, Math.min(1, i2 / this.wrapper.clientWidth)));
    }, () => this.isDragging = true, () => this.isDragging = false);
  }
  getHeight() {
    return null == this.options.height ? 128 : isNaN(Number(this.options.height)) ? "auto" === this.options.height && this.parent.clientHeight || 128 : Number(this.options.height);
  }
  initHtml() {
    const t2 = document.createElement("div"), e2 = t2.attachShadow({ mode: "open" });
    return e2.innerHTML = `
      <style>
        :host {
          user-select: none;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
          touch-action: none;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight()}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper">
          <div class="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `, [t2, e2];
  }
  setOptions(t2) {
    this.options = t2, this.reRender();
  }
  getWrapper() {
    return this.wrapper;
  }
  getScroll() {
    return this.scrollContainer.scrollLeft;
  }
  destroy() {
    var t2;
    this.container.remove(), null === (t2 = this.resizeObserver) || void 0 === t2 || t2.disconnect();
  }
  createDelay(t2 = 10) {
    const e2 = {};
    return this.timeouts.push(e2), (i2) => {
      e2.timeout && clearTimeout(e2.timeout), e2.timeout = setTimeout(i2, t2);
    };
  }
  convertColorValues(t2) {
    if (!Array.isArray(t2))
      return t2 || "";
    if (t2.length < 2)
      return t2[0] || "";
    const e2 = document.createElement("canvas"), i2 = e2.getContext("2d").createLinearGradient(0, 0, 0, e2.height), s2 = 1 / (t2.length - 1);
    return t2.forEach((t3, e3) => {
      const n2 = e3 * s2;
      i2.addColorStop(n2, t3);
    }), i2;
  }
  renderBars(t2, e2, i2) {
    if (i2.fillStyle = this.convertColorValues(e2.waveColor), e2.renderFunction)
      return void e2.renderFunction(t2, i2);
    const s2 = t2[0], n2 = t2[1] || t2[0], r2 = s2.length, o2 = window.devicePixelRatio || 1, { width: a2, height: h2 } = i2.canvas, l = h2 / 2, d = e2.barHeight || 1, c = e2.barWidth ? e2.barWidth * o2 : 1, u = e2.barGap ? e2.barGap * o2 : e2.barWidth ? c / 2 : 0, p = e2.barRadius || 0, m = a2 / (c + u) / r2;
    let g = 1;
    if (e2.normalize) {
      g = 0;
      for (let t3 = 0; t3 < r2; t3++) {
        const e3 = Math.abs(s2[t3]);
        e3 > g && (g = e3);
      }
    }
    const v = l / g * d, f = p && "roundRect" in i2 ? "roundRect" : "rect";
    i2.beginPath();
    let b = 0, y = 0, C = 0;
    for (let t3 = 0; t3 <= r2; t3++) {
      const r3 = Math.round(t3 * m);
      if (r3 > b) {
        const t4 = Math.round(y * v), s3 = t4 + Math.round(C * v) || 1;
        let n3 = l - t4;
        "top" === e2.barAlign ? n3 = 0 : "bottom" === e2.barAlign && (n3 = h2 - s3), i2[f](b * (c + u), n3, c, s3, p), b = r3, y = 0, C = 0;
      }
      const o3 = Math.abs(s2[t3] || 0), a3 = Math.abs(n2[t3] || 0);
      o3 > y && (y = o3), a3 > C && (C = a3);
    }
    i2.fill(), i2.closePath();
  }
  renderSingleCanvas(t2, e2, i2, s2, n2, r2, o2, a2) {
    const h2 = window.devicePixelRatio || 1, l = document.createElement("canvas"), d = t2[0].length;
    l.width = Math.round(i2 * (r2 - n2) / d), l.height = s2 * h2, l.style.width = `${Math.floor(l.width / h2)}px`, l.style.height = `${s2}px`, l.style.left = `${Math.floor(n2 * i2 / h2 / d)}px`, o2.appendChild(l);
    const c = l.getContext("2d");
    this.renderBars(t2.map((t3) => t3.slice(n2, r2)), e2, c);
    const u = l.cloneNode();
    a2.appendChild(u);
    const p = u.getContext("2d");
    l.width > 0 && l.height > 0 && p.drawImage(l, 0, 0), p.globalCompositeOperation = "source-in", p.fillStyle = this.convertColorValues(e2.progressColor), p.fillRect(0, 0, l.width, l.height);
  }
  renderWaveform(t2, e2, i2) {
    const s2 = document.createElement("div"), n2 = this.getHeight();
    s2.style.height = `${n2}px`, this.canvasWrapper.style.minHeight = `${n2}px`, this.canvasWrapper.appendChild(s2);
    const o2 = s2.cloneNode();
    this.progressWrapper.appendChild(o2);
    const { scrollLeft: a2, scrollWidth: h2, clientWidth: l } = this.scrollContainer, d = t2[0].length, c = d / h2;
    let u = Math.min(_r.MAX_CANVAS_WIDTH, l);
    if (e2.barWidth || e2.barGap) {
      const t3 = e2.barWidth || 0.5, i3 = t3 + (e2.barGap || t3 / 2);
      u % i3 != 0 && (u = Math.floor(u / i3) * i3);
    }
    const p = Math.floor(Math.abs(a2) * c), m = Math.floor(p + u * c), g = m - p, v = (r2, a3) => {
      this.renderSingleCanvas(t2, e2, i2, n2, Math.max(0, r2), Math.min(a3, d), s2, o2);
    }, f = this.createDelay(), b = this.createDelay(), y = (t3, e3) => {
      v(t3, e3), t3 > 0 && f(() => {
        y(t3 - g, e3 - g);
      });
    }, C = (t3, e3) => {
      v(t3, e3), e3 < d && b(() => {
        C(t3 + g, e3 + g);
      });
    };
    y(p, m), m < d && C(m, m + g);
  }
  render(t2) {
    this.timeouts.forEach((t3) => t3.timeout && clearTimeout(t3.timeout)), this.timeouts = [], this.canvasWrapper.innerHTML = "", this.progressWrapper.innerHTML = "", this.wrapper.style.width = "";
    const e2 = window.devicePixelRatio || 1, i2 = this.scrollContainer.clientWidth, s2 = Math.ceil(t2.duration * (this.options.minPxPerSec || 0));
    this.isScrolling = s2 > i2;
    const n2 = this.options.fillParent && !this.isScrolling, r2 = (n2 ? i2 : s2) * e2;
    if (this.wrapper.style.width = n2 ? "100%" : `${s2}px`, this.scrollContainer.style.overflowX = this.isScrolling ? "auto" : "hidden", this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar), this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`, this.cursor.style.width = `${this.options.cursorWidth}px`, this.options.splitChannels)
      for (let e3 = 0; e3 < t2.numberOfChannels; e3++) {
        const i3 = Object.assign(Object.assign({}, this.options), this.options.splitChannels[e3]);
        this.renderWaveform([t2.getChannelData(e3)], i3, r2);
      }
    else {
      const e3 = [t2.getChannelData(0)];
      t2.numberOfChannels > 1 && e3.push(t2.getChannelData(1)), this.renderWaveform(e3, this.options, r2);
    }
    this.audioData = t2, this.emit("render");
  }
  reRender() {
    if (!this.audioData)
      return;
    const t2 = this.progressWrapper.clientWidth;
    this.render(this.audioData);
    const e2 = this.progressWrapper.clientWidth;
    this.scrollContainer.scrollLeft += e2 - t2;
  }
  zoom(t2) {
    this.options.minPxPerSec = t2, this.reRender();
  }
  scrollIntoView(t2, e2 = false) {
    const { clientWidth: i2, scrollLeft: s2, scrollWidth: n2 } = this.scrollContainer, r2 = n2 * t2, o2 = i2 / 2;
    if (r2 > s2 + (e2 && this.options.autoCenter && !this.isDragging ? o2 : i2) || r2 < s2)
      if (this.options.autoCenter && !this.isDragging) {
        const t3 = o2 / 20;
        r2 - (s2 + o2) >= t3 && r2 < s2 + i2 ? this.scrollContainer.scrollLeft += t3 : this.scrollContainer.scrollLeft = r2 - o2;
      } else if (this.isDragging) {
        const t3 = 10;
        this.scrollContainer.scrollLeft = r2 < s2 ? r2 - t3 : r2 - i2 + t3;
      } else
        this.scrollContainer.scrollLeft = r2;
    {
      const { scrollLeft: t3 } = this.scrollContainer, e3 = t3 / n2, s3 = (t3 + i2) / n2;
      this.emit("scroll", e3, s3);
    }
  }
  renderProgress(t2, e2) {
    isNaN(t2) || (this.progressWrapper.style.width = 100 * t2 + "%", this.cursor.style.left = 100 * t2 + "%", this.cursor.style.marginLeft = 100 === Math.round(100 * t2) ? `-${this.options.cursorWidth}px` : "", this.isScrolling && this.options.autoScroll && this.scrollIntoView(t2, e2));
  }
};
r.MAX_CANVAS_WIDTH = 4e3;
var o = class extends s {
  constructor() {
    super(...arguments), this.unsubscribe = () => {
    };
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    }), this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
};
var a = { waveColor: "#999", progressColor: "#555", cursorWidth: 1, minPxPerSec: 0, fillParent: true, interact: true, autoScroll: true, autoCenter: true, sampleRate: 8e3 };
var h = class _h extends n {
  static create(t2) {
    return new _h(t2);
  }
  constructor(t2) {
    var e2, i2;
    super({ media: t2.media, mediaControls: t2.mediaControls, autoplay: t2.autoplay, playbackRate: t2.audioRate }), this.plugins = [], this.decodedData = null, this.duration = null, this.subscriptions = [], this.options = Object.assign({}, a, t2), this.timer = new o();
    const s2 = t2.media ? void 0 : this.getMediaElement();
    this.renderer = new r(this.options, s2), this.initPlayerEvents(), this.initRendererEvents(), this.initTimerEvents(), this.initPlugins();
    const n2 = this.options.url || (null === (e2 = this.options.media) || void 0 === e2 ? void 0 : e2.currentSrc) || (null === (i2 = this.options.media) || void 0 === i2 ? void 0 : i2.src);
    n2 && this.load(n2, this.options.peaks, this.options.duration);
  }
  initTimerEvents() {
    this.subscriptions.push(this.timer.on("tick", () => {
      const t2 = this.getCurrentTime();
      this.renderer.renderProgress(t2 / this.getDuration(), true), this.emit("timeupdate", t2), this.emit("audioprocess", t2);
    }));
  }
  initPlayerEvents() {
    this.subscriptions.push(this.onMediaEvent("timeupdate", () => {
      const t2 = this.getCurrentTime();
      this.renderer.renderProgress(t2 / this.getDuration(), this.isPlaying()), this.emit("timeupdate", t2);
    }), this.onMediaEvent("play", () => {
      this.emit("play"), this.timer.start();
    }), this.onMediaEvent("pause", () => {
      this.emit("pause"), this.timer.stop();
    }), this.onMediaEvent("ended", () => {
      this.emit("finish");
    }), this.onMediaEvent("seeking", () => {
      this.emit("seeking", this.getCurrentTime());
    }));
  }
  initRendererEvents() {
    this.subscriptions.push(this.renderer.on("click", (t2) => {
      this.options.interact && (this.seekTo(t2), this.emit("interaction", this.getCurrentTime()), this.emit("click", t2));
    }), this.renderer.on("scroll", (t2, e2) => {
      const i2 = this.getDuration();
      this.emit("scroll", t2 * i2, e2 * i2);
    }), this.renderer.on("render", () => {
      this.emit("redraw");
    }));
    {
      let t2;
      this.subscriptions.push(this.renderer.on("drag", (e2) => {
        this.options.interact && (this.renderer.renderProgress(e2), clearTimeout(t2), t2 = setTimeout(() => {
          this.seekTo(e2);
        }, this.isPlaying() ? 0 : 200), this.emit("interaction", e2 * this.getDuration()), this.emit("drag", e2));
      }));
    }
  }
  initPlugins() {
    var t2;
    (null === (t2 = this.options.plugins) || void 0 === t2 ? void 0 : t2.length) && this.options.plugins.forEach((t3) => {
      this.registerPlugin(t3);
    });
  }
  setOptions(t2) {
    this.options = Object.assign({}, this.options, t2), this.renderer.setOptions(this.options), t2.audioRate && this.setPlaybackRate(t2.audioRate), null != t2.mediaControls && (this.getMediaElement().controls = t2.mediaControls);
  }
  registerPlugin(t2) {
    return t2.init(this), this.plugins.push(t2), this.subscriptions.push(t2.once("destroy", () => {
      this.plugins = this.plugins.filter((e2) => e2 !== t2);
    })), t2;
  }
  getWrapper() {
    return this.renderer.getWrapper();
  }
  getScroll() {
    return this.renderer.getScroll();
  }
  getActivePlugins() {
    return this.plugins;
  }
  load(s2, n2, r2) {
    return t(this, void 0, void 0, function* () {
      this.isPlaying() && this.pause(), this.decodedData = null, this.duration = null, this.emit("load", s2);
      const t2 = n2 ? void 0 : yield i.fetchBlob(s2, this.options.fetchParams);
      if (this.setSrc(s2, t2), this.duration = (yield Promise.resolve(r2 || this.getDuration())) || (yield new Promise((t3) => {
        this.onceMediaEvent("loadedmetadata", () => t3(this.getDuration()));
      })) || (yield Promise.resolve(0)), n2)
        this.decodedData = e.createBuffer(n2, this.duration);
      else if (t2) {
        const i2 = yield t2.arrayBuffer();
        this.decodedData = yield e.decode(i2, this.options.sampleRate), 0 !== this.duration && this.duration !== 1 / 0 || (this.duration = this.decodedData.duration);
      }
      this.emit("decode", this.duration), this.decodedData && this.renderer.render(this.decodedData), this.emit("ready", this.duration);
    });
  }
  zoom(t2) {
    if (!this.decodedData)
      throw new Error("No audio loaded");
    this.renderer.zoom(t2), this.emit("zoom", t2);
  }
  getDecodedData() {
    return this.decodedData;
  }
  exportPeaks({ channels: t2 = 1, maxLength: e2 = 8e3, precision: i2 = 1e4 } = {}) {
    if (!this.decodedData)
      throw new Error("The audio has not been decoded yet");
    const s2 = Math.min(t2, this.decodedData.numberOfChannels), n2 = [];
    for (let t3 = 0; t3 < s2; t3++) {
      const s3 = this.decodedData.getChannelData(t3), r2 = Math.min(s3.length, e2), o2 = s3.length / r2, a2 = [];
      for (let t4 = 0; t4 < r2; t4++) {
        const e3 = s3[Math.round(t4 * o2)];
        a2.push(Math.round(e3 * i2) / i2);
      }
      n2.push(a2);
    }
    return n2;
  }
  getDuration() {
    return null !== this.duration ? this.duration : super.getDuration();
  }
  toggleInteraction(t2) {
    this.options.interact = t2;
  }
  seekTo(t2) {
    const e2 = this.getDuration() * t2;
    this.setTime(e2);
  }
  playPause() {
    return t(this, void 0, void 0, function* () {
      return this.isPlaying() ? this.pause() : this.play();
    });
  }
  stop() {
    this.pause(), this.setTime(0);
  }
  skip(t2) {
    this.setTime(this.getCurrentTime() + t2);
  }
  empty() {
    this.load("", [[0]], 1e-3);
  }
  destroy() {
    this.emit("destroy"), this.plugins.forEach((t2) => t2.destroy()), this.subscriptions.forEach((t2) => t2()), this.timer.destroy(), this.renderer.destroy(), super.destroy();
  }
};
export {
  h as default
};
//# sourceMappingURL=wavesurfer__js.js.map
